include::../../templates/ovm-header.adoc[]
:ovm-code: IT-AE-JA-INFO-5.1
:kind: Information
:short-title: Objektorientierte Software-Entwicklung 
= {kind} {ovm-code} {short-title}
André Bauer <a.bauer@ovm-kassel.de>
v1.0, 21. Februar 2018

include::../../templates/ovm-head-table.adoc[]

| *Links*
| 

| *Verwandte Literatur*
| IT-AE-JA-LS-5.1

| *Lizenz*
| {cc-by-sa}
|===

== Was ist objektorientierte Software-Entwicklung?

Spätestens wenn eine Software mehr als etwa hundert oder wenige hundert
Zeilen Quellcode umfasst, benötigt man Techniken, um der Software eine klare
Struktur zu geben. Eine klare Struktur ist wichtig, damit die Software leicht
angepasst und erweitert werden kann, sowohl durch bisherige als auch durch
andere Entwickler.

Eine sehr häufig angewandte Technik zum Entwurf und zur Strukturierung ist die
objektorientierte Software-Entwicklung. Dazu wird in der Entwurfsphase anhand
von Szenarien ermittelt, wie die zukünftige Nutzung des (Software-)Systems
ablaufen soll.
Dabei werden sogenannte
https://de.wikipedia.org/wiki/User-Story[User-Stories]
verfasst:

[[user-story-1]]
.User-Story 1
[quote]
____
Die Lampen L1, L2 und L3 sind anfangs ausgeschaltet. Der Schalter S1
ist ebenfalls in der Positon {ldquo}aus{rdquo}.
Der Benutzer betätigt den Schalter S1. Die Lampen  L1, L2 und L3 werden
eingeschaltet.
____

Aus den User-Stories können nun die relevanten Objekte abgeleitet werden;
im Beispiel sind dies der Benutzer, der Schalter S1 sowie die Lampen L1, L2 und
L3.

Stellt man die User-Story in einem
https://de.wikipedia.org/wiki/Sequenzdiagramm[UML-Sequenzdiagramm] dar,
so kann man den Programmablauf entlang der Pfeile ablesen.
So sendet der Schalter S1 die Nachricht `einschalten()` an die Lampe L1. Erst
wenn diese den Einschaltvorgang abgeschlossen hat, setzt S1 seine Arbeit
fort und sendet L2 die Nachricht _einschalten()_ usw.

[[sequenzdiagramm-1]]
.Sequenzdiagramm zur <<user-story-1>>
[plantuml, sequenzdiagramm-1, svg]
....
actor Benutzer

Benutzer -> "S1: Schalter" as S1: drücken()

S1 -> "L1: Lampe" as L1: einschalten()
L1 --> S1

S1 -> "L2: Lampe" as L2: einschalten()
L2 --> S1

S1 -> "L3: Lampe" as L3: einschalten()
L3 --> S1

S1 --> Benutzer
....

Eine zweite User-Story vervollständigt die möglichen Anwendungen:

[[user-story-2]]
.User-Story 2
[quote]
____
Die Lampen L1, L2 und L3 sind eingeschaltet. Der Schalter S1
ist ebenfalls in der Positon {ldquo}ein{rdquo}.
Der Benutzer betätigt den Schalter S1. Die Lampen  L1, L2 und L3 werden
ausgeschaltet.
____

Daraus ergibt sich das folgende Sequenzdiagramm:

[[sequenzdiagramm-2]]
.Sequenzdiagramm zur <<user-story-2>>
[plantuml, sequenzdiagramm-2, svg]
....
actor Benutzer

Benutzer -> "S1: Schalter" as S1: drücken()

S1 -> "L1: Lampe" as L1: ausschalten()
L1 --> S1

S1 -> "L2: Lampe" as L2: ausschalten()
L2 --> S1

S1 -> "L3: Lampe" as L3: ausschalten()
L3 --> S1

S1 --> Benutzer
....

Aus den User-Stories bzw. den zum zugehörigen Sequenzdiagrammen kann man
ablesen, wie die beteiligten Objekte miteinander verknüpt sein müssen,
um Nachrichten austauschen zu können:

Der Schalter S1 verwendet die Lampen L1, L2 und L3, um ihnen jeweils die
Nachricht `einschalten()` bzw. `ausschalten()` senden zu können.
Diese Beziehung wird in einem
https://de.wikipedia.org/wiki/Objektdiagramm[Objektdiagramm] durch Pfeile
dargestellt.

Daraus ergibt sich das folgende Objektdiagramm:

[[objektdiagramm-1]]
.Objektdiagramm für einen Aufbau mit einem Schalter und drei Lampen zu Beginn der <<user-story-1>>
[plantuml, {ovm-code}-objektdiagramm-schalter-drei-lampen-1, svg]
....
object "<u>S1: Schalter</u>" as S1 {
  zustand = AUS
} 

object "<u>L1: Lampe</u>" as L1 {
  zustand = AUS
} 

object "<u>L2: Lampe</u>" as L2 {
  zustand = AUS
} 

object "<u>L3: Lampe</u>" as L3 {
  zustand = AUS
} 

L1 <- S1 : schaltet

S1 -> "schaltet" L3

S1 -> L2 : schaltet
....

Ein Objektdiagramm stellt den Zustand eines Software-Systems zu einen
bestimmten Zeitpunkt dar. +
Das Diagramm in <<objektdiagramm-1>> stellt den
Zustand zu Beginn der <<user-story-1>> bzw. zum Ende der
<<user-story-2>> dar, da der Schalter und die Lampen den Zustand `AUS` haben.

Den Zustand zum Ende der <<user-story-1>> bzw. zu Beinn der <<user-story-2>>
sieht so aus:

[[objektdiagramm-2]]
.Objektdiagramm für einen Aufbau mit einem Schalter und drei Lampen zum Ende der <<user-story-1>>
[plantuml, objektdiagramm-schalter-drei-lampen-2, svg]
....
object "<u>S1: Schalter</u>" as S1 {
  zustand = EIN
} 

object "<u>L1: Lampe</u>" as L1 {
  zustand = EIN
} 

object "<u>L2: Lampe</u>" as L2 {
  zustand = EIN
} 

object "<u>L3: Lampe</u>" as L3 {
  zustand = EIN
} 

L1 <- S1 : schaltet

S1 -> "schaltet" L3

S1 -> L2 : schaltet
....

Man könnte jetzt den Schalter und die drei Lampen direkt programmieren, aber
dies hätte Nachteile:

* für die Lampen würde man dreimal dasselbe Programm schreiben

* es wäre eine unflexibele Lösung, man möchte mit derselben
  Software auch Schaltungen
  mit vier oder mehr Lampen mit einem Schalter verbinden können.

[[objektdiagramm-b]]
.Objektdiagramm für einen Aufbau mit einem Schalter und fünf Lampen
[plantuml, objektdiagramm-schalter-fuenf-lampen, svg]
....
object "<u>S1: Schalter</u>" as S1 {
  zustand = AUS
} 

object "<u>L1: Lampe</u>" as L1 {
  zustand = AUS
} 

object "<u>L2: Lampe</u>" as L2 {
  zustand = AUS
} 

object "<u>L3: Lampe</u>" as L3 {
  zustand = AUS
} 

object "<u>L4: Lampe</u>" as L4 {
  zustand = AUS
} 

object "<u>L5: Lampe</u>" as L5 {
  zustand = AUS
} 


L1 <- S1 : schaltet

S1 -> "schaltet" L3

S1 -> L2 : schaltet

S1 -> L4 : schaltet

S1 -> L5 : schaltet
....

Daher verallgemeinert man die möglichen Objektbeziehungen in Form eines
https://de.wikipedia.org/wiki/Klassendiagramm[UML-Klassendiagramms]:

[[klassendiagramm-1]]
.Klassendiagramm
[plantuml, klassendiagramm-schalter-lampe, svg]
....
class "Schalter" as S1 {
  zustand
  drücken()
} 

class "Lampe" as L1 {
  zustand
  einschalten()
  ausschalten()
}

S1 "1" --> "*" L1 : schaltet
note right on link
  Durch den Beziehungspfeil wird notiert, dass ein Schalter mit
  mehreren Lampen verbunden werden kann.
end note
....

In einem Klassendiagramm werden Objekte mit derselben Struktur zu einer
Klasse zusammengefasst.
Die Lampen L1, L2 und L3 werden also zu den Klasse `Lampe` zusammengefasst.
Die Nachricht `drücken()` wird
dem Schalter und `ausschalten()` bei `Lampe` notiert, also jeweils bei der
Klasse, der die entsprechende Nachricht gesendet wird.
Die Daten, die auch Attribute der Objekte bzw. Klassen genannt werden,
werden im Klassendiagramm
nicht mehr mit konkreten Werten angegeben, sondern statt dessen der
entsprechende Datentyp.

Das Klassendiagramm stellt im Gegensatz zu einem Objektdiagramm keinen
Systemzustand dar, sondern die Struktur der zugrundeliegenden Software
bzw. des Quellcodes.

In dem Objektdiagrammen <<objektdiagramm-1>> und <<objektdiagramm-2>>
haben die Objekte das
Attribut `zustand` mit den möglichen Werten `ON` und `OFF.`
Anstatt eines vorhandenen Java-Datentyps wie `int`, `boolean` oder `string`
erstellen wir mithilfe einer Aufzählung (engl. enumeration, in Java abgekürzt
zu `enum`)
einen passenden neuen und aussagekräftigen.

[[listing-enum-state]]
.Enum State in Java
[source,java]
----
enum State {
  ON,
  OFF
}
----

Die Aufzählung `State` ergänzen wir in dem Klassendiagramm und
verwenden zudem ab jetzt englische Begriffe. Die Verwendung englischer
Sprache im Quellcode ist üblich, da bei den meisten Programmiersprachen
für die Sprachelemente sowie die
https://de.wikipedia.org/wiki/Programmbibliothek[Programmbibliotheken]
ohnehin englische Sprache verwendet wird, wie z.B. auch bein Java. 

[[klassendiagramm-2]]
.Klassendiagramm mit Enum und englischen Begriffen
[plantuml, klassendiagramm-schalter-lampe-enum, svg]
....
class "Switch" as S1 {
  state: State
  press()
} 

class "Lamp" as L1 {
  state: State
  turnOn()
  turnOff()
}

class "State" << enum >> 

S1 "1" --> "*" L1 : controls
S1 -> State
L1 -> State
....

Sowohl `Switch` als auch `Lamp` verwenden `State`, was durch Pfeile
in <<klassendiagramm-2>> gekennzeichnet ist.

Damit haben wir aus den User-Stories eine objektorientierte Struktur
für die Software entworfen. Man nennt diesen Schritt
https://de.wikipedia.org/wiki/Objektorientierte_Analyse_und_Design[*objektorientierte Modellierung*].

Dem Klassendiagramm entspricht das folgende Java-Programm:

.Java-Programm
[source,java]
----
enum State {
  ON,
  OFF
}

public class Switch {
       private State state;

       public void press() {

       }      
}

public class Lamp {
       private State state;

       public void turnOn() {

       }

       public void turnOff() {

       }      
}       
----

Ist damit die Entwicklung der Software abgeschlossen?
Nein, noch nicht, wir haben bislang erst eine objektorientierte Struktur
erstellt.

== Wie kann der Schalter die Lampen steuern?

* Wir benötigen Konstruktoren, die wie in den Unser-Stories den
  Anfangszustand herstellen und Objekte einer Klasse kreieren.

* Die Beziehungen zwischen den Objekten müssen erzeugt werden.
  Dazu betrachten wir zunächst eine Vereinfachung:

* Die Aktionen der Objekte, wenn sie eine Nachricht erhalten,
  müssen programmiert werden, das heißt die Methoden
  `press()` in `Switch`
  und `turnOn()` sowie `turnOff()` in Lamp. 

[[klassendiagramm-3]]
.vereinfachstes Klassendiagramm mit Enum und englischen Begriffen
[plantuml, klassendiagramm-schalter-lampe-vereinfacht, svg]
....
class "State" << enum >> 

class "Switch" as S1 {
  state: State
  Switch()
  press()
  connect(Lamp)
  disconnect(Lamp)
} 

class "Lamp" as L1 {
  state: State
  Lamp()
  turnOn()
  turnOff()
}

S1 -> State
L1 -> State

S1 "1" --> "1" L1 : controls
note right on link
  Der Schalter kann jetzt nur
  noch eine Lampe verwenden,
  eine 1-zu-1-Beziehung.
end note
....

.Java-Programm
[source,java]
----
include::src/switch-with-single-lamp.java[]
----

Mit diesen Klassen können jetzt die Objekte `l1` und `s1` erzeugt werden
und die Lampe `l1` mit dem Schalter `s1` verbunden werden.

.Java-Programm
[source,java]
----
Lamp l1 = new Lamp(); <1>
Switch s1 = new Switch(); <2>
s1.connect(l1); <3>
s1.press(); <4>
----
<1> Eine neues Objekt der Klasse Lamp mit dem Bezeichner `l1` wird erzeugt.
<2> Eine neues Objekt der Klasse Switch mit dem Bezeichner `s1` wird erzeugt.
<3> Die Lampe `l1` wird mit dem Schalter `s1` verbunden.
<4> {ldquo}Betätigen{rdqou} des Schalters.

=== Wie kann man mehrere Lampen mit einem Schalter verbinden?

Wir benötigen dazu eine Objekt-Sammlung im Switch. In Java gibt es dazu
vorgefertigte Komponenten, z.B. eine
https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html[ArrayList].
Diese hat u.a. die Methoden

add:: Fügt der Sammlung ein Objekt hinzu.

remove:: Entfernt ein Objekt aus der Sammlung.

Zudem gibt es in Java eine besondere `for`-Schleife für Collections:

.Java-Programm
[source,java]
....
for (Lamp l: lamps) { <1>
    l.turnOn(); <2>
}
....
<1> In dem Schleifenkopf wird eine Collection ausgewählt, hier `lamps` sowie
    ein Bezeichner `l` der Klasse `Lamp`, der in dem Schleifenrumpf gültig ist.
<2> Im Schleifenrumpf wirden die Aktionen festgelegt, die mit jedem
    Objekt der Sammlung durchgeführt werden, dazu verwendet man den oben
    festgelegten Bezeichner `l`.

Der vollständige Quellcode, der <<user-story-1>> entspricht.:

.Java-Programm
[source,java]
----
include::src/SwitchWithMultipleLamps.java[]
----